# A Simple OISC CPU

## Introduction
In this lab I have built an OISC (One-instruction set computer) simulator. An OISC is perhaps the simplest CPU implementation in existence, even more so than RISCs (Reduced-instruction set computers).
A OISC is a type of CPU architecture that executes programs using a single instruction, and if implemented correctly, is theoretically capable of running any program designed for any other CPU. These types of CPUs
are implemented in a Hardware Description Language like Verilog or VHDL. However, for this case,
a high level software language like Java will be chosen to simulate the operation of such a machine.

In this case, the CPU is modelled for
Cryptoleq, which is a language consisting of just one instruction, subleq, known in Assembly as `subl`. 
  
As a reminder, subleq is defined as:

    `subl a, b, c:`  
    `memory[b] = memory[b] - memory[a]`  
    `if (memory[b] <= 0) goto c`
## Design Principle
Cryptoleq is able to modify specific memory cells
using direct and multiple layers of indirect addressing. The general idea implemented in this design is:

The CPU accesses a memory region defined by the `int` array `memory`, with `N` entries. The program counter, `pc`, is always `memory[0]` and this location of memory holds the next address to process.

At each clock cycle or time step, the CPU uses three memory addresses, `memory[pc]`, `memory[pc + 1]`, and `memory[pc + 2]`. Let `v1`, `v2` and `v3` be the **values** at these three addresses, respectively. The CPU performs the following operation:

1. Compute `memory[v1] - memory[v2]` and use this value to replace `memory[v1]`; and
2. If the new value at `memory[v1]` is less than or equal to 0 then update the value of the program counter to `v3` otherwise increment the value of the program counter by 3.

The CPU stops execution when there is an attempt to read a value outside the bounds of the memory array, and when this happens the value at `memory[1]` is returned as the output of whatever "program" was being executed.

## Implementation
Let us analyze the implementation in Java. In the `StarCPU` class are two methods: `simulate()` and `addProgram(int a, int b)`.  
The `simulate()` method is quite straightforward as it is just an implementation of the pseudocode mentioned above. Given a "program" (implemented as an int array), the method will simulate the CPU until it stops (i.e. triggered an out of bounds execption).


The `addProgram(int a, int b)` method is also straightforward but time consuming to write, and is almost completely hardcoded for the addition operation.  
The method writes a "program" (again, an int array) to calculate the output of two ints, `a` and `b`.  
Using the operation of the CPU defined above, one can hardcode the contents of the program array such that the program returns the correct sum after the CPU stops by intentionally triggering the exception.  

## Memory Content Generation  
The hardcoded array was generated by hand, with variable substitutions for `a` and `b` at certain indicies.
The idea can be summarized as follows:  

1. Store the value of `-a/2` because of the array content restriction that **no element of the array may be greater than max(a/2, b/2, 100)**  
2. Store the value of `-a` by using the above operation.
3. Store the value of `(-a-b)/2`.
4. Store the value of `-a-b`.
5. Finally, subtract `-a-b` from `0` to obtain the desired `a+b` sum.

The following pseudocode will explain the memory generation process using layered indirection on the memory array `mem[]`.  
When the single layer of indirection is used, it refers to setting an array element to a desired value for an operation. When two or more layers are used, this is done to allow `pc` to update to the desirable array index to continue execution.  

First, `a` and `b` must be sorted based on whether they are even or odd as future operations will depend on division truncating.  
In particular, when divided by 2, then multiplied with 2, odd numbers will suffer from losing 1 due to truncation.  
Thus, these edge cases must be taken care of first by providing a certain base offset of 0,1,2 as shown in the pseudocode below:  

    a /= 2;  
    b /= 2;  
    mem[0]=pc; //always  

    if ( a and b are even) {  
        mem[1]=0;  
    } else if ( a and b are odd ) {  
        mem[1]=2;  
    } else {  
        mem[1]=1;  
    }  

Then, the 5 steps outlined above will be done in order: 

    //0-a/2  
    location1 = pc; //save initial PC address  
    mem[pc]=pc+3;      //populate with mem[pc],mem[pc+1],mem[pc+2]  
    mem[pc+1]=pc+4;  
    mem[pc+2]=pc+5;  
    mem[mem[pc]]=0;    // the value at mem[pc] is 0  
    mem[mem[pc+1]]=a;  // the value at mem[pc+1] is a   

    //0-a/2-a/2  
    pc+=6;  
    location2 = pc;  
    mem[pc]=mem[location1];     //mem[location1] is actually -a  
    mem[pc+1]=pc+3;  
    mem[mem[pc+1]]=a;
    mem[pc+2]=pc+4;
    
    //0-a/2-a/2-b/2  
    pc+=5;  
    location3=pc;  
    mem[pc]=mem[location1];  
    mem[pc+1]=pc+3;  
    mem[pc+2]=pc+4;  
    mem[mem[pc+1]]=b;
    
    //0-a/2=a/2-b/2-b/2  
    pc+=5;  
    location4=pc;  
    mem[pc]=mem[location1];  
    mem[pc+1]=pc+3;  
    mem[pc+2]=pc+4;  
    mem[mem[pc+1]]=b;  
    mem[mem[pc+2]]=pc+5;  
    
    //0-(0-a/2-a/2-b/2-b/2)  
    pc+=5;  
    location5 = pc;  
    mem[pc]=1;  
    mem[pc+1]=mem[location1];  
    //result is a+b  
    mem[pc+2]=random;  
    pc+=3; //update PC  
    mem[pc]=100; //trigger out of bounds exception  

Thus, based on the pseudocode above, the resulting array for the sum operation should be of the form:  
`2,0,5,6,7,0,a/2,5,10,11,a/2,5,14,15,b/2,5,18,19,b/2,1,5,2,100`  
with the necessary truncation offsets mentioned previously.

##Example Operation and Testing
An example of the CPU modifying the memory would be an operation `3+6`.  
The produced array would be {2,0,5,6,7,0,1,5,10,11,1,5,14,15,3,5,18,19,3,1,5,2}.  
The modified array (after the operation) would be {22,9,5,6,7,-8,1,5,10,11,1,5,14,15,3,5,18,19,3,1,5,2,100}.  
Notice that the produced array strictly conforms to the element size restriction mentioned above.
Also, the return value in the modified array with index 1 is 9, the correct sum of 3+6.  

Testing was done using both methods to verify the operation and execution of the CPU and program generator.
  
## References  
https://en.wikipedia.org/wiki/One-instruction_set_computer  
https://www.youtube.com/watch?v=o0e7_U7ZmBM&t=1068s  
https://www.sccs.swarthmore.edu/users/06/adem/engin/e25/finale/  